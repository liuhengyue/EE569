////  raw.cpp//  ////  Created by LiuHengyue on 10/5/15.//  Copyright Â© 2015 LiuHengyue. All rights reserved.//////These codes are data structures related; raw image and data interfaces.//Note: opencv is not allowed in homework 3, the ShowImg() function just invokes Mat() and imshow() for display result image for convenience.#include "raw.h"/************************************************************************* *class imageData memeber function realizations  *************************************************************************/imageData::imageData(){    }imageData::imageData(const char* filePath,const int width,const int length,const int bytesPerPixel){    unsigned char* imgPtr=ReadRaw(filePath, width, length, bytesPerPixel);    _length=length;    _width=width;    _bytesPerPixel=bytesPerPixel;    _dataPtr=new unsigned char**[width];    int i,j,dim;    for(i=0;i<width;i++){//array row        _dataPtr[i]=new unsigned char*[length];        for(j=0;j<length;j++){//coloumn            _dataPtr[i][j]=new unsigned char[bytesPerPixel];            //BGR->RGB            for(dim=0;dim<bytesPerPixel;dim++){                _dataPtr[i][j][dim]=imgPtr[(j*width+i)*bytesPerPixel+bytesPerPixel-dim-1];                            }        }    }    }imageData::imageData(const int width,const int length,const int bytesPerPixel){    _length=length;    _width=width;    _bytesPerPixel=bytesPerPixel;    _dataPtr=new unsigned char**[width];    int i,j,dim;    for(i=0;i<width;i++){//array row        _dataPtr[i]=new unsigned char*[length];        for(j=0;j<length;j++){//coloumn            _dataPtr[i][j]=new unsigned char[bytesPerPixel];            //since opencv uses BGR, change the channel order of image array            //BGR->RGB            for(dim=0;dim<bytesPerPixel;dim++){                //default all zeros                _dataPtr[i][j][dim]=0;                            }        }    }}imageData::~imageData(){    }imageData imageData::createData(){     return imageData(_width,_length,_bytesPerPixel);}imageData imageData::copy(){    imageData copied(_width,_length,_bytesPerPixel);    for(int i=0;i<_width;i++){//array row        for(int j=0;j<_length;j++){//coloumn            for(int dim=0;dim<_bytesPerPixel;dim++){                //copy all data                copied._dataPtr[i][j][dim]=_dataPtr[i][j][dim];                            }        }    }    return copied;}/************************************************************************* * ReadRaw() * Function: This function reads in image data from a RAW image file. * Input: file path of the image, size of the image. * Output: the pointer of the image array. *************************************************************************/unsigned char* ReadRaw(const char *filename, const int width,const int length,const int bytesPerPixel){    // Allocate image data array using new() for transmiting array pointer    unsigned char *imagePtr;    imagePtr=new unsigned char[width*length*bytesPerPixel];    FILE *file;    // Open file    if (!(file=fopen(filename,"rb"))) {        cout << "Cannot open file: " << filename <<endl;        exit(1);    }    fread(imagePtr, sizeof(unsigned char), width*length*bytesPerPixel, file);    fclose(file);    return imagePtr;//return the address of the first pixel}/************************************************************************* * WriteRaw() * Function: This function write image data from a in a RAW file. * Input: file path one wants to create, image data array pointer, size of the image. *************************************************************************/void WriteRaw(const char *path, unsigned char* imagePtr, const int width,const int length,  const int bytesPerPixel){    FILE *file;    //const char* path="/Users/liuhengyue/Google Drive/EE569/hw2/569HW2/569HW2/straw_01ba.raw";    if (!(file=fopen(path,"wb"))) {        cout << "Cannot open file: " << path << endl;        exit(1);    }    unsigned char outImage[length][width][bytesPerPixel];    int i=0,j=0,dim=0;    for(dim=0;dim<bytesPerPixel;dim++){        for(i=0;i<length;i++){//array row number            for(j=0;j<width;j++){//coloumn number                outImage[i][j][dim]=imagePtr[(i*width+j)*bytesPerPixel+bytesPerPixel-dim-1];            }        }    }    fwrite(outImage, sizeof(unsigned char), width*length*bytesPerPixel, file);    fclose(file);}/************************************************************************* * ShowImg() * Function: This function reads the image data as vector format, and use imshow() to display the image. * Input: object of class imageData. * Output: the image Mat(). *************************************************************************/void ShowImg(const char* name,imageData img){    int i=0,j=0;    //define image matrix(color)    if(img._bytesPerPixel==3){        cv::Mat imgMat(img._length,img._width,CV_8UC3);                for(i=0;i<img._length;i++){//array ro_dataPtr            for(j=0;j<img._width;j++){//coloumn                //assigning Mat() values                imgMat.at<Vec3b>(i,j)[0]=img._dataPtr[j][i][0];                imgMat.at<Vec3b>(i,j)[1]=img._dataPtr[j][i][1];                imgMat.at<Vec3b>(i,j)[2]=img._dataPtr[j][i][2];                }        }            imshow(name,imgMat);    }    //define gray level image    if (img._bytesPerPixel==1) {        cv::Mat imgMat(img._length,img._width,CV_8UC1);        for(i=0;i<img._length;i++){//array ro_dataPtr            //coloumn            for(j=0;j<img._width;j++){                //assigning Mat() values                imgMat.at<unsigned char>(i,j)=img._dataPtr[j][i][0];            }        }        namedWindow(name,0);        imshow(name,imgMat);    }    //display image        waitKey(0);}